<%
const { modelTypes, utils, config, routes } = it;
const { formatDescription, require, _, Ts } = utils;

// Load dynamic naming utilities
const namingUtils = includeFile("./naming-utils", { utils });

// Collect all routes for analysis
const allRoutes = [];
if (routes && routes.combined) {
  routes.combined.forEach(group => {
    if (group.routes) {
      allRoutes.push(...group.routes);
    }
  });
}

const buildGenerics = (contract) => {
  if (!contract.genericArgs || !contract.genericArgs.length) return '';

  return '<' + contract.genericArgs.map(({ name, default: defaultType, extends: extendsType }) => {
    return [
      name,
      extendsType && `extends ${extendsType}`,
      defaultType && `= ${defaultType}`,
    ].join('')
  }).join(',') + '>'
}

const dataContractTemplates = {
  enum: (contract) => {
    return `enum ${contract.name} {\r\n${contract.content} \r\n }`;
  },
  interface: (contract) => {
    return `interface ${contract.name}${buildGenerics(contract)} {\r\n${contract.content}}`;
  },
  type: (contract) => {
    return `type ${contract.name}${buildGenerics(contract)} = ${contract.content}`;
  },
}

// All dynamic logic is now handled in the included dynamic-naming.ejs file

// Get configuration options
const exportOriginalTypes = config.internalTemplateOptions && config.internalTemplateOptions.exportOriginalTypes !== undefined 
  ? config.internalTemplateOptions.exportOriginalTypes 
  : false; // Default to false (internal)

const exportMethodTypesOnly = config.internalTemplateOptions && config.internalTemplateOptions.exportMethodTypesOnly !== undefined 
  ? config.internalTemplateOptions.exportMethodTypesOnly 
  : true; // Default to true (only export method types)
%>

<% if (config.internalTemplateOptions.addUtilRequiredKeysType) { %>
type <%~ config.Ts.CodeGenKeyword.UtilRequiredKeys %><T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>
<% } %>

<% /* Generate original types (internal or exported based on config) */ %>
<% for (const contract of modelTypes) { %>
  <%~ includeFile('./data-contract-jsdoc.ejs', { ...it, data: { ...contract, ...contract.typeData } }) %>
  <%~ exportOriginalTypes ? 'export ' : '' %><%~ (dataContractTemplates[contract.typeIdentifier] || dataContractTemplates.type)(contract) %>


<% } %>

<% /* Generate method-specific input and response types (exported) */ %>
<% if (routes && routes.combined && routes.combined.length > 0) { %>

<% /* Method-specific type aliases for better type safety */ %>
<% 
// Track generated type names to avoid duplicates using Set
const generatedTypeNames = new Set();
const getUniqueTypeName = (baseName) => {
  let counter = 0;
  let typeName = baseName;
  while (generatedTypeNames.has(typeName)) {
    counter++;
    typeName = `${baseName}${counter}`;
  }
  generatedTypeNames.add(typeName);
  return typeName;
};
%>
<% for (const { routes: combinedRoutes = [] } of routes.combined) { %>
<% for (const route of combinedRoutes) { %>
<% 
// Use dynamic naming logic to get resolved names
const routeNaming = namingUtils.getRouteNaming(route, allRoutes, utils);
const inputTypeName = getUniqueTypeName(routeNaming.inputTypeName);
const resultTypeName = getUniqueTypeName(routeNaming.resultTypeName);
const simpleMethodName = routeNaming.methodName;
%>

<% /* Generate input type */ %>
<% const pathParams = _.values(route.request.parameters || {}); %>
<% const hasPayload = route.request.payload && route.request.payload.type; %>
<% const hasQuery = route.request.query && route.request.query.type; %>
<% const hasPathParams = pathParams.length > 0; %>

<% if (hasPayload && hasPathParams) { %>
/** Input type for <%~ simpleMethodName %> method */
export type <%~ inputTypeName %> = {
<% pathParams.forEach(param => { %>
  /** <%~ param.description || param.name %> */
  <%~ param.name %>: <%~ param.type %>;
<% }); %>
} & <%~ route.request.payload.type %>;
<% } else if (hasPayload) { %>
/** Input type for <%~ simpleMethodName %> method */
export type <%~ inputTypeName %> = <%~ route.request.payload.type %>;
<% } else if (hasQuery && hasPathParams) { %>
/** Input type for <%~ simpleMethodName %> method */
export type <%~ inputTypeName %> = {
<% pathParams.forEach(param => { %>
  /** <%~ param.description || param.name %> */
  <%~ param.name %>: <%~ param.type %>;
<% }); %>
} & <%~ route.request.query.type %>;
<% } else if (hasQuery) { %>
/** Input type for <%~ simpleMethodName %> method */
export type <%~ inputTypeName %> = <%~ route.request.query.type %>;
<% } else if (hasPathParams) { %>
/** Input type for <%~ simpleMethodName %> method */
export type <%~ inputTypeName %> = {
<% pathParams.forEach(param => { %>
  /** <%~ param.description || param.name %> */
  <%~ param.name %>: <%~ param.type %>;
<% }); %>
};
<% } else { %>
/** Input type for <%~ simpleMethodName %> method */
export type <%~ inputTypeName %> = void;
<% } %>

<% /* Generate result type */ %>
<% if (route.response.type && route.response.type !== 'void' && route.response.type !== 'any') { %>
/** Result type for <%~ simpleMethodName %> method */
export type <%~ resultTypeName %> = <%~ route.response.type %>;
<% } else { %>
/** Result type for <%~ simpleMethodName %> method */
export type <%~ resultTypeName %> = any;
<% } %>

<% } %>
<% } %>
<% } %>
