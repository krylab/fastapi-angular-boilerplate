<%
const { modelTypes, utils, config, routes } = it;
const { formatDescription, require, _, Ts } = utils;

const buildGenerics = (contract) => {
  if (!contract.genericArgs || !contract.genericArgs.length) return '';

  return '<' + contract.genericArgs.map(({ name, default: defaultType, extends: extendsType }) => {
    return [
      name,
      extendsType && `extends ${extendsType}`,
      defaultType && `= ${defaultType}`,
    ].join('')
  }).join(',') + '>'
}

const dataContractTemplates = {
  enum: (contract) => {
    return `enum ${contract.name} {\r\n${contract.content} \r\n }`;
  },
  interface: (contract) => {
    return `interface ${contract.name}${buildGenerics(contract)} {\r\n${contract.content}}`;
  },
  type: (contract) => {
    return `type ${contract.name}${buildGenerics(contract)} = ${contract.content}`;
  },
}

// Helper function to create method-specific type names - simplified without "Api" prefix  
const createMethodTypeName = (methodName, path, suffix) => {
  // Convert method name to PascalCase
  const pascalMethodName = methodName.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()).replace(/\s+/g, '');
  
  // Always return just the method name + suffix, no "Api" prefix
  return `${pascalMethodName}${suffix}`;
};

// Helper function to convert kebab-case to camelCase
const toCamelCase = (str) => {
  return str.replace(/-([a-z])/g, (match, letter) => letter.toUpperCase());
};

// Create a simplified method name from the route - no prefix, just the action
const createSimpleMethodName = (routeName, path, method) => {
  // Split path into segments and filter out empty and parameter segments
  // Also filter out ${id} patterns
  const pathSegments = path.split('/').filter(p => p && !p.startsWith('{') && !p.startsWith('${'));
  
  if (pathSegments.length >= 2) {
    // Get the action from the last meaningful segment
    const action = pathSegments[pathSegments.length - 1];
    const camelAction = toCamelCase(action);
    
    // Check for duplicate actions that need context
    const duplicateActions = ['login', 'logout'];
    if (duplicateActions.includes(camelAction.toLowerCase())) {
      // Add context from the path to avoid duplicates
      const context = pathSegments[pathSegments.length - 2]; // e.g., 'jwt', 'cookie'
      if (context) {
        return `${camelAction}${_.upperFirst(toCamelCase(context))}`;
      }
    }
    
    // For routes like /users/me, /auth/register, /auth/login, etc.
    // Just return the action without any prefix
    return camelAction;
  }
  
  if (pathSegments.length === 1) {
    // For single segment paths like /users, /auth
    // Use method + resource but in a cleaner way
    const resource = pathSegments[0];
    const lowerMethod = method.toLowerCase();
    const camelResource = toCamelCase(resource);
    
    // For common patterns, just use the resource name
    const commonResources = ['users', 'auth', 'plans', 'tiers', 'rateLimits'];
    if (commonResources.includes(resource)) {
      return camelResource;
    }
    
    return `${lowerMethod}${_.upperFirst(camelResource)}`;
  }
  
  // Fallback: clean up the original route name and convert to camelCase
  if (routeName && typeof routeName === 'string') {
    // Split by uppercase letters and filter out empty strings
    const words = routeName.split(/(?=[A-Z])/).filter(w => w.length > 0);
    
    // Remove duplicate consecutive words (case-insensitive)
    const cleanWords = [];
    let lastWord = '';
    for (const word of words) {
      if (word.toLowerCase() !== lastWord.toLowerCase()) {
        cleanWords.push(word);
        lastWord = word;
      }
    }
    
    // If we have multiple words, take the last meaningful word
    if (cleanWords.length > 1) {
      const lastWord = cleanWords[cleanWords.length - 1];
      return toCamelCase(lastWord.toLowerCase());
    }
    
    return toCamelCase(routeName.toLowerCase());
  }
  
  // Final fallback
  return method.toLowerCase();
};

// Create unique method name by adding HTTP method prefix only when duplicates occur
const createUniqueMethodName = (routeName, path, method) => {
  const baseName = createSimpleMethodName(routeName, path, method);
  const lowerMethod = method.toLowerCase();
  const pathSegments = path.split('/').filter(p => p && !p.startsWith('{') && !p.startsWith('${'));
  
  // Define patterns that are likely to have duplicates
  const duplicatePatterns = [
    // Same resource name with different HTTP methods
    'tiers', 'rateLimits', 'users', 'me', 'health',
    // Specific method patterns that cause duplicates
    'getTiers', 'postTiers', 'getRateLimits', 'postRateLimits',
    // Same endpoint pattern with different HTTP methods
    'plans'
  ];
  
  // Check if this base name is likely to have duplicates
  if (duplicatePatterns.includes(baseName.toLowerCase())) {
    return `${lowerMethod}${_.upperFirst(baseName)}`;
  }
  
  // For resource with ID patterns, always add HTTP method to avoid conflicts
  if (path.includes('{') && pathSegments.length >= 2) {
    return `${lowerMethod}${_.upperFirst(baseName)}`;
  }
  
  // Special handling for specific duplicate cases we've seen
  if (baseName.toLowerCase() === 'gettiers' && lowerMethod === 'get') {
    return `${lowerMethod}${_.upperFirst(baseName)}`;
  }
  
  // Always add prefix for rateLimits to avoid conflicts
  if (baseName.toLowerCase() === 'ratelimits') {
    return `${lowerMethod}${_.upperFirst(baseName)}`;
  }
  
  return baseName;
};

// Helper function to create a proper method name that handles path parameters
const createProperMethodName = (routeName, path, method) => {
  // Check if the path contains path parameters
  if (path.includes('{')) {
    // Extract the parameter name from the path
    const paramMatch = path.match(/\{([^}]+)\}/);
    if (paramMatch) {
      const paramName = paramMatch[1];
      // Create a method name that includes the parameter name and HTTP method
      const lowerMethod = method.toLowerCase();
      const baseName = createSimpleMethodName(routeName, path, method);
      
      // Special handling for specific cases - always include HTTP method for parameterized endpoints
      if (path.includes('/tiers/{tier_id}')) {
        return `${lowerMethod}TiersByTierId`;
      }
      if (path.includes('/rate-limits/{rate_limit_id}')) {
        return `${lowerMethod}RateLimitsByRateLimitId`;
      }
      
      // Convert snake_case to camelCase for parameter names
      const camelParamName = paramName.replace(/_([a-z])/g, (match, letter) => letter.toUpperCase());
      return `${lowerMethod}${_.upperFirst(baseName)}By${_.upperFirst(camelParamName)}`;
    }
  }
  
  // For non-parameterized endpoints, check if we need to add HTTP method to avoid duplicates
  const baseName = createSimpleMethodName(routeName, path, method);
  const lowerMethod = method.toLowerCase();
  
  // Add HTTP method prefix for endpoints that typically have multiple methods
  if (path.includes('/tiers') || path.includes('/rate-limits')) {
    return `${lowerMethod}${_.upperFirst(baseName)}`;
  }
  
  return baseName;
};

// Helper function to create a clean method name for type generation
const createCleanMethodName = (routePath, realPath, method) => {
  // Check if the path contains {id} patterns (standard OpenAPI parameter placeholders)
  if (routePath.includes('{')) {
    // Extract the parameter name from the path
    const paramMatch = routePath.match(/\{([^}]+)\}/);
    if (paramMatch) {
      const paramName = paramMatch[1];
      // Create a method name that includes the parameter name  
      const baseName = createSimpleMethodName('', routePath, method);
      return `${baseName}${_.upperFirst(paramName)}`;
    }
  }
  
  return createSimpleMethodName('', routePath, method);
};

// Get configuration options
const exportOriginalTypes = config.internalTemplateOptions && config.internalTemplateOptions.exportOriginalTypes !== undefined 
  ? config.internalTemplateOptions.exportOriginalTypes 
  : false; // Default to false (internal)

const exportMethodTypesOnly = config.internalTemplateOptions && config.internalTemplateOptions.exportMethodTypesOnly !== undefined 
  ? config.internalTemplateOptions.exportMethodTypesOnly 
  : true; // Default to true (only export method types)
%>

<% if (config.internalTemplateOptions.addUtilRequiredKeysType) { %>
type <%~ config.Ts.CodeGenKeyword.UtilRequiredKeys %><T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>
<% } %>

<% /* Generate original types (internal or exported based on config) */ %>
<% for (const contract of modelTypes) { %>
  <%~ includeFile('./data-contract-jsdoc.ejs', { ...it, data: { ...contract, ...contract.typeData } }) %>
  <%~ exportOriginalTypes ? 'export ' : '' %><%~ (dataContractTemplates[contract.typeIdentifier] || dataContractTemplates.type)(contract) %>


<% } %>

<% /* Generate method-specific input and response types (exported) */ %>
<% if (routes && routes.combined && routes.combined.length > 0) { %>

<% /* Method-specific type aliases for better type safety */ %>
<% 
// Track generated type names to avoid duplicates
const generatedTypeNames = new Set();
const getUniqueTypeName = (baseName) => {
  let counter = 0;
  let typeName = baseName;
  while (generatedTypeNames.has(typeName)) {
    counter++;
    typeName = `${baseName}${counter}`;
  }
  generatedTypeNames.add(typeName);
  return typeName;
};
%>
<% for (const { routes: combinedRoutes = [] } of routes.combined) { %>
<% for (const route of combinedRoutes) { %>
<% 
// Use raw.route and raw.method instead of the verbose routeName.usage
const simpleMethodName = createProperMethodName(route.raw.route, route.raw.route, route.raw.method);
const baseInputTypeName = createMethodTypeName(simpleMethodName, route.request.path, 'Input');
const baseResultTypeName = createMethodTypeName(simpleMethodName, route.request.path, 'Result');
const inputTypeName = getUniqueTypeName(baseInputTypeName);
const resultTypeName = getUniqueTypeName(baseResultTypeName);
%>

<% /* Generate input type */ %>
<% const pathParams = _.values(route.request.parameters || {}); %>
<% const hasPayload = route.request.payload && route.request.payload.type; %>
<% const hasQuery = route.request.query && route.request.query.type; %>
<% const hasPathParams = pathParams.length > 0; %>

<% if (hasPayload && hasPathParams) { %>
/** Input type for <%~ simpleMethodName %> method */
export type <%~ inputTypeName %> = {
<% pathParams.forEach(param => { %>
  /** <%~ param.description || param.name %> */
  <%~ param.name %>: <%~ param.type %>;
<% }); %>
} & <%~ route.request.payload.type %>;
<% } else if (hasPayload) { %>
/** Input type for <%~ simpleMethodName %> method */
export type <%~ inputTypeName %> = <%~ route.request.payload.type %>;
<% } else if (hasQuery && hasPathParams) { %>
/** Input type for <%~ simpleMethodName %> method */
export type <%~ inputTypeName %> = {
<% pathParams.forEach(param => { %>
  /** <%~ param.description || param.name %> */
  <%~ param.name %>: <%~ param.type %>;
<% }); %>
} & <%~ route.request.query.type %>;
<% } else if (hasQuery) { %>
/** Input type for <%~ simpleMethodName %> method */
export type <%~ inputTypeName %> = <%~ route.request.query.type %>;
<% } else if (hasPathParams) { %>
/** Input type for <%~ simpleMethodName %> method */
export type <%~ inputTypeName %> = {
<% pathParams.forEach(param => { %>
  /** <%~ param.description || param.name %> */
  <%~ param.name %>: <%~ param.type %>;
<% }); %>
};
<% } else { %>
/** Input type for <%~ simpleMethodName %> method */
export type <%~ inputTypeName %> = void;
<% } %>

<% /* Generate result type */ %>
<% if (route.response.type && route.response.type !== 'void' && route.response.type !== 'any') { %>
/** Result type for <%~ simpleMethodName %> method */
export type <%~ resultTypeName %> = <%~ route.response.type %>;
<% } else { %>
/** Result type for <%~ simpleMethodName %> method */
export type <%~ resultTypeName %> = any;
<% } %>

<% } %>
<% } %>
<% } %>
