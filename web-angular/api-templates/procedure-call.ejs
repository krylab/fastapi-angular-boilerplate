<%
const { utils, route, config } = it;
const { requestBodyInfo, responseBodyInfo, specificArgNameResolver } = route;
const { _, getInlineParseContent, getParseContent, parseSchema, getComponentByRef, require } = utils;
const { parameters, path, method, payload, query, formData, security, requestParams } = route.request;
const { type, errorType, contentTypes } = route.response;
const { raw, request, routeName } = route;
const { HTTP_CLIENT, RESERVED_REQ_PARAMS_ARG_NAMES } = config.constants;
const routeDocs = includeFile("./route-docs", { config, route, utils });
const queryName = (query && query.name) || "query";
const pathParams = _.values(parameters);
const pathParamsNames = _.map(pathParams, "name");

const argToTmpl = ({ name, optional, type, defaultValue }) => `${name}${!defaultValue && optional ? '?' : ''}: ${type}${defaultValue ? ` = ${defaultValue}` : ''}`;

const rawWrapperArgs = config.extractRequestParams ?
    _.compact([
        requestParams && {
          name: pathParams.length ? `{ ${_.join(pathParamsNames, ", ")}, ...${queryName} }` : queryName,
          optional: false,
          type: getInlineParseContent(requestParams),
        },
        ...(!requestParams ? pathParams : []),
        payload,
    ]) :
    _.compact([
        ...pathParams,
        query,
        payload,
    ])

const wrapperArgs = _
    // Sort by optionality
    .sortBy(rawWrapperArgs, [o => o.optional])
    .map(argToTmpl)
    .join(', ')

const bodyTmpl = _.get(payload, "name") || null;
const queryTmpl = (query != null && queryName) || null;

const hasParams = wrapperArgs.length > 0;

const isValidIdentifier = (name) => /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(name);

// Helper function to convert kebab-case to camelCase
const toCamelCase = (str) => {
  return str.replace(/-([a-z])/g, (match, letter) => letter.toUpperCase());
};

// Create a simplified method name from the route - no prefix, just the action
const createSimpleMethodName = (routeName, path, method) => {
  // Split path into segments and filter out empty and parameter segments
  // Also filter out ${id} patterns
  const pathSegments = path.split('/').filter(p => p && !p.startsWith('{') && !p.startsWith('${'));
  
  if (pathSegments.length >= 2) {
    // Get the action from the last meaningful segment
    const action = pathSegments[pathSegments.length - 1];
    const camelAction = toCamelCase(action);
    
    // Check for duplicate actions that need context
    const duplicateActions = ['login', 'logout'];
    if (duplicateActions.includes(camelAction.toLowerCase())) {
      // Add context from the path to avoid duplicates
      const context = pathSegments[pathSegments.length - 2]; // e.g., 'jwt', 'cookie'
      if (context) {
        return `${camelAction}${_.upperFirst(toCamelCase(context))}`;
      }
    }
    
    // For routes like /users/me, /auth/register, /auth/login, etc.
    // Just return the action without any prefix
    return camelAction;
  }
  
  if (pathSegments.length === 1) {
    // For single segment paths like /users, /auth
    // Use method + resource but in a cleaner way
    const resource = pathSegments[0];
    const lowerMethod = method.toLowerCase();
    const camelResource = toCamelCase(resource);
    
    // For common patterns, just use the resource name
    const commonResources = ['users', 'auth', 'plans', 'tiers', 'rateLimits'];
    if (commonResources.includes(resource)) {
      return camelResource;
    }
    
    return `${lowerMethod}${_.upperFirst(camelResource)}`;
  }
  
  // Fallback: clean up the original route name and convert to camelCase
  if (routeName && typeof routeName === 'string') {
    // Split by uppercase letters and filter out empty strings
    const words = routeName.split(/(?=[A-Z])/).filter(w => w.length > 0);
    
    // Remove duplicate consecutive words (case-insensitive)
    const cleanWords = [];
    let lastWord = '';
    for (const word of words) {
      if (word.toLowerCase() !== lastWord.toLowerCase()) {
        cleanWords.push(word);
        lastWord = word;
      }
    }
    
    // If we have multiple words, take the last meaningful word
    if (cleanWords.length > 1) {
      const lastWord = cleanWords[cleanWords.length - 1];
      return toCamelCase(lastWord.toLowerCase());
    }
    
    return toCamelCase(routeName.toLowerCase());
  }
  
  // Final fallback
  return method.toLowerCase();
};

// Create unique method name by adding HTTP method prefix only when duplicates occur
const createUniqueMethodName = (routeName, path, method) => {
  const baseName = createSimpleMethodName(routeName, path, method);
  const lowerMethod = method.toLowerCase();
  const pathSegments = path.split('/').filter(p => p && !p.startsWith('{') && !p.startsWith('${'));
  
  // Define patterns that are likely to have duplicates
  const duplicatePatterns = [
    // Same resource name with different HTTP methods
    'tiers', 'rateLimits', 'users', 'me', 'health',
    // Specific method patterns that cause duplicates
    'getTiers', 'postTiers', 'getRateLimits', 'postRateLimits',
    // Same endpoint pattern with different HTTP methods
    'plans'
  ];
  
  // Check if this base name is likely to have duplicates
  if (duplicatePatterns.includes(baseName.toLowerCase())) {
    return `${lowerMethod}${_.upperFirst(baseName)}`;
  }
  
  // For resource with ID patterns, always add HTTP method to avoid conflicts
  if (path.includes('{') && pathSegments.length >= 2) {
    return `${lowerMethod}${_.upperFirst(baseName)}`;
  }
  
  // Special handling for specific duplicate cases we've seen
  if (baseName.toLowerCase() === 'gettiers' && lowerMethod === 'get') {
    return `${lowerMethod}${_.upperFirst(baseName)}`;
  }
  
  // Always add prefix for rateLimits to avoid conflicts
  if (baseName.toLowerCase() === 'ratelimits') {
    return `${lowerMethod}${_.upperFirst(baseName)}`;
  }
  
  return baseName;
};

// Helper function to create a proper method name that handles path parameters
const createProperMethodName = (routeName, path, method) => {
  // Check if the path contains path parameters
  if (path.includes('{')) {
    // Extract the parameter name from the path
    const paramMatch = path.match(/\{([^}]+)\}/);
    if (paramMatch) {
      const paramName = paramMatch[1];
      // Create a method name that includes the parameter name and HTTP method
      const lowerMethod = method.toLowerCase();
      const baseName = createSimpleMethodName(routeName, path, method);
      
      // Special handling for specific cases - always include HTTP method for parameterized endpoints
      if (path.includes('/tiers/{tier_id}')) {
        return `${lowerMethod}TiersByTierId`;
      }
      if (path.includes('/rate-limits/{rate_limit_id}')) {
        return `${lowerMethod}RateLimitsByRateLimitId`;
      }
      
      // Convert snake_case to camelCase for parameter names
      const camelParamName = paramName.replace(/_([a-z])/g, (match, letter) => letter.toUpperCase());
      return `${lowerMethod}${_.upperFirst(baseName)}By${_.upperFirst(camelParamName)}`;
    }
  }
  
  // For non-parameterized endpoints, check if we need to add HTTP method to avoid duplicates
  const baseName = createSimpleMethodName(routeName, path, method);
  const lowerMethod = method.toLowerCase();
  
  // Add HTTP method prefix for endpoints that typically have multiple methods
  if (path.includes('/tiers') || path.includes('/rate-limits')) {
    return `${lowerMethod}${_.upperFirst(baseName)}`;
  }
  
  return baseName;
};

// Helper function to create a clean method name for type generation
const createCleanMethodName = (routePath, realPath, method) => {
  // Check if the path contains {id} patterns (standard OpenAPI parameter placeholders)
  if (routePath.includes('{')) {
    // Extract the parameter name from the path
    const paramMatch = routePath.match(/\{([^}]+)\}/);
    if (paramMatch) {
      const paramName = paramMatch[1];
      // Create a method name that includes the parameter name  
      const baseName = createSimpleMethodName('', routePath, method);
      return `${baseName}${_.upperFirst(paramName)}`;
    }
  }
  
  return createSimpleMethodName('', routePath, method);
};

// Helper function to create method-specific type names - simplified without "Api" prefix  
const createMethodTypeName = (methodName, path, suffix) => {
  // Convert method name to PascalCase
  const pascalMethodName = methodName.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()).replace(/\s+/g, '');
  
  // Always return just the method name + suffix, no "Api" prefix
  return `${pascalMethodName}${suffix}`;
};

// Fix parameter type to include Types namespace if it's a custom type
const getTypeWithNamespace = (paramType) => {
  if (!paramType) return 'any';
  // If it's a primitive type, return as-is
  if (['string', 'number', 'boolean', 'any', 'unknown', 'void'].includes(paramType)) {
    return paramType;
  }
  // If it already has Types namespace, return as-is
  if (paramType.startsWith('Types.')) {
    return paramType;
  }
  // Add Types namespace for custom types
  return `Types.${paramType}`;
};

// Determine the correct parameter type using method-specific types
let requestParamsType = 'any';
if (requestParams) {
  requestParamsType = getTypeWithNamespace(getInlineParseContent(requestParams));
} else if (payload && payload.type) {
  // Use the payload type directly for request body
  const payloadType = getTypeWithNamespace(payload.type);
  if (query && query.type) {
    const queryType = getTypeWithNamespace(query.type);
    requestParamsType = `{ data: ${payloadType} } & ${queryType}`;
  } else {
    requestParamsType = `{ data: ${payloadType} }`;
  }
} else if (query && query.type) {
  requestParamsType = getTypeWithNamespace(query.type);
}

// Use raw.route and raw.method instead of the verbose routeName.usage
const simpleMethodName = createProperMethodName(route.raw.route, route.raw.route, route.raw.method);
const inputTypeName = createMethodTypeName(simpleMethodName, path, 'Input');
const resultTypeName = createMethodTypeName(simpleMethodName, path, 'Result');

// Use method-specific types instead of original types
const methodInputType = `Types.${inputTypeName}`;
const methodResultType = `Types.${resultTypeName}`;
%>

/**
<%~ routeDocs.description %>

 *<% /* Here you can add some other JSDoc tags */ %>

<%~ routeDocs.lines %>

 * @param host Optional base URL host (e.g., 'https://api.example.com') to override the default relative URL
 */
<% if (isValidIdentifier(simpleMethodName)) { %><%~ simpleMethodName %><% } else { %>"<%~ simpleMethodName %>"<% } %> = <% if (hasParams) { %>(params: Signal<<%~ methodInputType %> | undefined>, host?: string)<% } else { %>(trigger?: Signal<any>, host?: string)<% } %> => {
  return httpResource<% if (methodResultType && methodResultType !== 'void' && methodResultType !== 'any') { %><<%~ methodResultType %>><% } %>(() => {
    <% if (hasParams) { %>
    const resolvedParams = params();
    if (!resolvedParams) return undefined;
    <% } else { %>
    if (!trigger?.()) return undefined;
    <% } %>
    
    <% if (pathParams.length > 0) { %>
    let url = host ? `${host}<%~ raw.route %>` : '<%~ raw.route %>';
    <% pathParams.forEach(param => { %>
    <% if (hasParams) { %>
    url = url.replace('{<%~ param.name %>}', String(resolvedParams.<%~ param.name %>));
    <% } %>
    <% }); %>
    <% } else { %>
    const url = host ? `${host}<%~ raw.route %>` : '<%~ raw.route %>';
    <% } %>

    <% if (query) { %>
    const queryParams: Record<string, string> = {};
    <% if (hasParams) { %>
    // Extract query parameters (excluding path parameters)
    <% if (pathParams.length > 0) { %>
    const pathParamNames = [<%~ pathParamsNames.map(name => `'${name}'`).join(', ') %>];
    Object.entries(resolvedParams).forEach(([key, value]) => {
      if (!pathParamNames.includes(key) && value !== undefined && value !== null) {
        queryParams[key] = String(value);
      }
    });
    <% } else { %>
    Object.entries(resolvedParams).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        queryParams[key] = String(value);
      }
    });
    <% } %>
    <% } %>
    <% } %>

    return {
      url,
      method: '<%~ _.upperCase(method) %>',
      <% if (query) { %>
      params: queryParams,
      <% } %>
      <% if (bodyTmpl && hasParams) { %>
      body: resolvedParams,
      <% } %>
      <% if (requestBodyInfo.contentType) { %>
      headers: {
        'Content-Type': '<%~ requestBodyInfo.contentType %>'
      }
      <% } %>
    };
  });
}; 