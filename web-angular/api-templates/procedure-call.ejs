<%
const { utils, route, config, routes } = it;
const { requestBodyInfo, responseBodyInfo, specificArgNameResolver } = route;
const { _, getInlineParseContent, getParseContent, parseSchema, getComponentByRef, require } = utils;
const { parameters, path, method, payload, query, formData, security, requestParams } = route.request;
const { type, errorType, contentTypes } = route.response;
const { raw, request, routeName } = route;
const { HTTP_CLIENT, RESERVED_REQ_PARAMS_ARG_NAMES } = config.constants;
const routeDocs = includeFile("./route-docs", { config, route, utils });
const queryName = (query && query.name) || "query";
const pathParams = _.values(parameters);
const pathParamsNames = _.map(pathParams, "name");

// Load dynamic naming utilities
const namingUtils = includeFile("./naming-utils", { utils });

// Collect all routes for analysis
const allRoutes = [];
if (routes && routes.combined) {
  routes.combined.forEach(group => {
    if (group.routes) {
      allRoutes.push(...group.routes);
    }
  });
}

// Get dynamic naming for this route
const routeNaming = namingUtils.getRouteNaming(route, allRoutes, utils);

const argToTmpl = ({ name, optional, type, defaultValue }) => `${name}${!defaultValue && optional ? '?' : ''}: ${type}${defaultValue ? ` = ${defaultValue}` : ''}`;

const rawWrapperArgs = config.extractRequestParams ?
    _.compact([
        requestParams && {
          name: pathParams.length ? `{ ${_.join(pathParamsNames, ", ")}, ...${queryName} }` : queryName,
          optional: false,
          type: getInlineParseContent(requestParams),
        },
        ...(!requestParams ? pathParams : []),
        payload,
    ]) :
    _.compact([
        ...pathParams,
        query,
        payload,
    ])

const wrapperArgs = _
    // Sort by optionality
    .sortBy(rawWrapperArgs, [o => o.optional])
    .map(argToTmpl)
    .join(', ')

const bodyTmpl = _.get(payload, "name") || null;
const queryTmpl = (query != null && queryName) || null;

const hasParams = wrapperArgs.length > 0;

const isValidIdentifier = (name) => /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(name);

// Fix parameter type to include Types namespace if it's a custom type
const getTypeWithNamespace = (paramType) => {
  if (!paramType) return 'any';
  // If it's a primitive type, return as-is
  if (['string', 'number', 'boolean', 'any', 'unknown', 'void'].includes(paramType)) {
    return paramType;
  }
  // If it already has Types namespace, return as-is
  if (paramType.startsWith('Types.')) {
    return paramType;
  }
  // Add Types namespace for custom types
  return `Types.${paramType}`;
};

// Determine the correct parameter type using method-specific types
let requestParamsType = 'any';
if (requestParams) {
  requestParamsType = getTypeWithNamespace(getInlineParseContent(requestParams));
} else if (payload && payload.type) {
  // Use the payload type directly for request body
  const payloadType = getTypeWithNamespace(payload.type);
  if (query && query.type) {
    const queryType = getTypeWithNamespace(query.type);
    requestParamsType = `{ data: ${payloadType} } & ${queryType}`;
  } else {
    requestParamsType = `{ data: ${payloadType} }`;
  }
} else if (query && query.type) {
  requestParamsType = getTypeWithNamespace(query.type);
}

// Use dynamic naming from the analysis
const simpleMethodName = routeNaming.methodName;
const inputTypeName = routeNaming.inputTypeName;
const resultTypeName = routeNaming.resultTypeName;

// Use method-specific types instead of original types
const methodInputType = `Types.${inputTypeName}`;
const methodResultType = `Types.${resultTypeName}`;
%>

/**
<%~ routeDocs.description %>

 *<% /* Here you can add some other JSDoc tags */ %>

<%~ routeDocs.lines %>

 * @param host Optional base URL host (e.g., 'https://api.example.com') to override the default relative URL
 */
<% if (isValidIdentifier(simpleMethodName)) { %><%~ simpleMethodName %><% } else { %>"<%~ simpleMethodName %>"<% } %> = <% if (hasParams) { %>(params: Signal<<%~ methodInputType %> | undefined>, host?: string)<% } else { %>(trigger?: Signal<any>, host?: string)<% } %> => {
  return httpResource<% if (methodResultType && methodResultType !== 'void' && methodResultType !== 'any') { %><<%~ methodResultType %>><% } %>(() => {
    <% if (hasParams) { %>
    const resolvedParams = params();
    if (!resolvedParams) return undefined;
    <% } else { %>
    if (!trigger?.()) return undefined;
    <% } %>
    
    <% if (pathParams.length > 0) { %>
    let url = host ? `${host}<%~ raw.route %>` : '<%~ raw.route %>';
    <% pathParams.forEach(param => { %>
    <% if (hasParams) { %>
    url = url.replace('{<%~ param.name %>}', String(resolvedParams.<%~ param.name %>));
    <% } %>
    <% }); %>
    <% } else { %>
    const url = host ? `${host}<%~ raw.route %>` : '<%~ raw.route %>';
    <% } %>

    <% if (query) { %>
    const queryParams: Record<string, string> = {};
    <% if (hasParams) { %>
    // Extract query parameters (excluding path parameters)
    <% if (pathParams.length > 0) { %>
    const pathParamNames = [<%~ pathParamsNames.map(name => `'${name}'`).join(', ') %>];
    Object.entries(resolvedParams).forEach(([key, value]) => {
      if (!pathParamNames.includes(key) && value !== undefined && value !== null) {
        queryParams[key] = String(value);
      }
    });
    <% } else { %>
    Object.entries(resolvedParams).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        queryParams[key] = String(value);
      }
    });
    <% } %>
    <% } %>
    <% } %>

    return {
      url,
      method: '<%~ _.upperCase(method) %>',
      <% if (query) { %>
      params: queryParams,
      <% } %>
      <% if (bodyTmpl && hasParams) { %>
      body: resolvedParams,
      <% } %>
      <% if (requestBodyInfo.contentType) { %>
      headers: {
        'Content-Type': '<%~ requestBodyInfo.contentType %>'
      }
      <% } %>
    };
  });
}; 