<%
const { utils, route, config } = it;
const { requestBodyInfo, responseBodyInfo, specificArgNameResolver } = route;
const { _, getInlineParseContent, getParseContent, parseSchema, getComponentByRef, require } = utils;
const { parameters, path, method, payload, query, formData, security, requestParams } = route.request;
const { type, errorType, contentTypes } = route.response;
const { raw, request, routeName } = route;
const { HTTP_CLIENT, RESERVED_REQ_PARAMS_ARG_NAMES } = config.constants;
const routeDocs = includeFile("./route-docs", { config, route, utils });
const queryName = (query && query.name) || "query";
const pathParams = _.values(parameters);
const pathParamsNames = _.map(pathParams, "name");

const argToTmpl = ({ name, optional, type, defaultValue }) => `${name}${!defaultValue && optional ? '?' : ''}: ${type}${defaultValue ? ` = ${defaultValue}` : ''}`;

const rawWrapperArgs = config.extractRequestParams ?
    _.compact([
        requestParams && {
          name: pathParams.length ? `{ ${_.join(pathParamsNames, ", ")}, ...${queryName} }` : queryName,
          optional: false,
          type: getInlineParseContent(requestParams),
        },
        ...(!requestParams ? pathParams : []),
        payload,
    ]) :
    _.compact([
        ...pathParams,
        query,
        payload,
    ])

const wrapperArgs = _
    // Sort by optionality
    .sortBy(rawWrapperArgs, [o => o.optional])
    .map(argToTmpl)
    .join(', ')

const bodyTmpl = _.get(payload, "name") || null;
const queryTmpl = (query != null && queryName) || null;

const hasParams = wrapperArgs.length > 0;

const isValidIdentifier = (name) => /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(name);

// Helper function to convert kebab-case to camelCase
const toCamelCase = (str) => {
  return str.replace(/-([a-z])/g, (match, letter) => letter.toUpperCase());
};

// Create a simplified method name from the route
const createSimpleMethodName = (routeName, path, method) => {
  // Split path into segments and filter out empty and parameter segments
  // Also filter out ${id} patterns
  const pathSegments = path.split('/').filter(p => p && !p.startsWith('{') && !p.startsWith('${'));
  
  if (pathSegments.length >= 1) {
    const resource = pathSegments[0]; // e.g., 'redis', 'users', 'auth' 
    let action = pathSegments[1]; // e.g., 'get', 'set', 'register'
    
    if (!action) {
      // If no action specified, use method + resource (e.g., 'getUsers')
      return `${method.toLowerCase()}${_.upperFirst(toCamelCase(resource))}`;
    }
    
    // Convert action to camelCase
    const camelAction = toCamelCase(action);
    const lowerMethod = method.toLowerCase();
    
    // Check if action already contains the method name
    if (camelAction.toLowerCase().includes(lowerMethod)) {
      // If action already includes method, just use action (e.g., 'get' from '/redis/get')
      return camelAction;
    }
    
    // For routes like /users/me where the action doesn't contain the method,
    // we need to include the method to avoid conflicts between GET /users/me and PATCH /users/me
    const commonActions = ['me', 'profile', 'settings', 'current'];
    if (commonActions.includes(camelAction.toLowerCase())) {
      return `${lowerMethod}${_.upperFirst(camelAction)}`;
    }
    
    // Handle nested paths like /auth/jwt/login or /auth/google/callback
    if (pathSegments.length > 2) {
      const subResource = toCamelCase(pathSegments[1]); // e.g., 'jwt', 'google'
      const finalAction = toCamelCase(pathSegments[2] || method.toLowerCase()); // e.g., 'login', 'callback'
      return `${subResource}${_.upperFirst(finalAction)}`;
    }
    
    // Create the final method name: action (e.g., 'register', 'forgotPassword')
    return camelAction;
  }
  
  // Fallback: clean up the original route name and convert to camelCase
  // Remove duplicate words and create a cleaner method name
  if (routeName && typeof routeName === 'string') {
    // Split by uppercase letters and filter out empty strings
    const words = routeName.split(/(?=[A-Z])/).filter(w => w.length > 0);
    
    // Remove duplicate consecutive words (case-insensitive)
    const cleanWords = [];
    let lastWord = '';
    for (const word of words) {
      if (word.toLowerCase() !== lastWord.toLowerCase()) {
        cleanWords.push(word);
        lastWord = word;
      }
    }
    
    // If we have multiple words, create a better method name
    if (cleanWords.length > 1) {
      const firstWord = cleanWords[0].toLowerCase();
      const lastWord = cleanWords[cleanWords.length - 1];
      return `${firstWord}${lastWord}`;
    }
    
    return toCamelCase(routeName.toLowerCase());
  }
  
  // Final fallback using method and path
  return `${method.toLowerCase()}${pathSegments.length > 0 ? _.upperFirst(toCamelCase(pathSegments[pathSegments.length - 1])) : 'Unknown'}`;
};

// Helper function to create a proper method name that handles path parameters
const createProperMethodName = (routeName, path, method) => {
  // Check if the path contains path parameters
  if (path.includes('{')) {
    // Extract the parameter name from the path
    const paramMatch = path.match(/\{([^}]+)\}/);
    if (paramMatch) {
      const paramName = paramMatch[1];
      // Create a method name that includes the parameter name
      const baseName = createSimpleMethodName(routeName, path, method);
      return `${baseName}${_.upperFirst(paramName)}`;
    }
  }
  
  return createSimpleMethodName(routeName, path, method);
};

// Helper function to create a clean method name for type generation
const createCleanMethodName = (routePath, realPath, method) => {
  // Check if the path contains {id} patterns (standard OpenAPI parameter placeholders)
  if (routePath.includes('{')) {
    // Extract the parameter name from the path
    const paramMatch = routePath.match(/\{([^}]+)\}/);
    if (paramMatch) {
      const paramName = paramMatch[1];
      // Create a method name that includes the parameter name  
      const baseName = createSimpleMethodName('', routePath, method);
      return `${baseName}${_.upperFirst(paramName)}`;
    }
  }
  
  return createSimpleMethodName('', routePath, method);
};

// Helper function to create method-specific type names with resource context
const createMethodTypeName = (methodName, path, suffix) => {
  // Extract resource from path for better type naming
  const pathSegments = path.split('/').filter(p => p && !p.startsWith('{') && !p.startsWith('${'));
  const resource = pathSegments.length >= 1 ? pathSegments[0] : '';
  
  // Convert method name to PascalCase
  const pascalMethodName = methodName.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()).replace(/\s+/g, '');
  
  // If methodName already includes resource context, use as-is
  const resourceCamelCase = _.upperFirst(toCamelCase(resource));
  if (pascalMethodName.includes(resourceCamelCase)) {
    return `${pascalMethodName}${suffix}`;
  }
  
  // For specific patterns that need resource context to avoid conflicts
  const needsResourceContext = [
    'Get', 'Post', 'Put', 'Patch', 'Delete',  // Generic HTTP methods
    'GetMe', 'PatchMe', 'Me',                 // Common endpoint patterns
    'Jwt', 'Cookie', 'Google',                // Auth patterns
    'Login', 'Logout', 'Register'             // Auth actions
  ];
  
  if (needsResourceContext.some(pattern => pascalMethodName.includes(pattern)) && resource) {
    return `${pascalMethodName}${resourceCamelCase}${suffix}`;
  }
  
  // For short names, add resource context
  if (resource && pascalMethodName.length <= 4) {
    return `${pascalMethodName}${resourceCamelCase}${suffix}`;
  }
  
  // For duplicate or overly generic names like 'GetGet', fix them
  if (pascalMethodName.toLowerCase().match(/^(get|post|put|patch|delete)\1$/i) && resource) {
    const cleanMethod = pascalMethodName.substring(0, pascalMethodName.length / 2);
    return `${cleanMethod}${resourceCamelCase}${suffix}`;
  }
  
  return `${pascalMethodName}${suffix}`;
};

// Fix parameter type to include Types namespace if it's a custom type
const getTypeWithNamespace = (paramType) => {
  if (!paramType) return 'any';
  // If it's a primitive type, return as-is
  if (['string', 'number', 'boolean', 'any', 'unknown', 'void'].includes(paramType)) {
    return paramType;
  }
  // If it already has Types namespace, return as-is
  if (paramType.startsWith('Types.')) {
    return paramType;
  }
  // Add Types namespace for custom types
  return `Types.${paramType}`;
};

// Determine the correct parameter type using method-specific types
let requestParamsType = 'any';
if (requestParams) {
  requestParamsType = getTypeWithNamespace(getInlineParseContent(requestParams));
} else if (payload && payload.type) {
  // Use the payload type directly for request body
  const payloadType = getTypeWithNamespace(payload.type);
  if (query && query.type) {
    const queryType = getTypeWithNamespace(query.type);
    requestParamsType = `{ data: ${payloadType} } & ${queryType}`;
  } else {
    requestParamsType = `{ data: ${payloadType} }`;
  }
} else if (query && query.type) {
  requestParamsType = getTypeWithNamespace(query.type);
}

// Use raw.route and raw.method instead of the verbose routeName.usage
const simpleMethodName = createCleanMethodName(route.raw.route, route.raw.route, route.raw.method);
const inputTypeName = createMethodTypeName(simpleMethodName, path, 'Input');
const resultTypeName = createMethodTypeName(simpleMethodName, path, 'Result');

// Use method-specific types instead of original types
const methodInputType = `Types.${inputTypeName}`;
const methodResultType = `Types.${resultTypeName}`;
%>

/**
<%~ routeDocs.description %>

 *<% /* Here you can add some other JSDoc tags */ %>

<%~ routeDocs.lines %>

 * @param host Optional base URL host (e.g., 'https://api.example.com') to override the default relative URL
 */
<% if (isValidIdentifier(simpleMethodName)) { %><%~ simpleMethodName %><% } else { %>"<%~ simpleMethodName %>"<% } %> = <% if (hasParams) { %>(params: Signal<<%~ methodInputType %> | undefined>, host?: string)<% } else { %>(trigger?: Signal<any>, host?: string)<% } %> => {
  return httpResource<% if (methodResultType && methodResultType !== 'void' && methodResultType !== 'any') { %><<%~ methodResultType %>><% } %>(() => {
    <% if (hasParams) { %>
    const resolvedParams = params();
    if (!resolvedParams) return undefined;
    <% } else { %>
    if (!trigger?.()) return undefined;
    <% } %>
    
    <% if (pathParams.length > 0) { %>
    let url = host ? `${host}<%~ raw.route %>` : '<%~ raw.route %>';
    <% pathParams.forEach(param => { %>
    <% if (hasParams) { %>
    url = url.replace('{<%~ param.name %>}', String(resolvedParams.<%~ param.name %>));
    <% } %>
    <% }); %>
    <% } else { %>
    const url = host ? `${host}<%~ raw.route %>` : '<%~ raw.route %>';
    <% } %>

    <% if (query) { %>
    const queryParams: Record<string, string> = {};
    <% if (hasParams) { %>
    // Extract query parameters (excluding path parameters)
    <% if (pathParams.length > 0) { %>
    const pathParamNames = [<%~ pathParamsNames.map(name => `'${name}'`).join(', ') %>];
    Object.entries(resolvedParams).forEach(([key, value]) => {
      if (!pathParamNames.includes(key) && value !== undefined && value !== null) {
        queryParams[key] = String(value);
      }
    });
    <% } else { %>
    Object.entries(resolvedParams).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        queryParams[key] = String(value);
      }
    });
    <% } %>
    <% } %>
    <% } %>

    return {
      url,
      method: '<%~ _.upperCase(method) %>',
      <% if (query) { %>
      params: queryParams,
      <% } %>
      <% if (bodyTmpl && hasParams) { %>
      body: resolvedParams,
      <% } %>
      <% if (requestBodyInfo.contentType) { %>
      headers: {
        'Content-Type': '<%~ requestBodyInfo.contentType %>'
      }
      <% } %>
    };
  });
}; 