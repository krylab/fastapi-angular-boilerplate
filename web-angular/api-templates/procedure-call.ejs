<%
const { utils, route, config } = it;
const { requestBodyInfo, responseBodyInfo, specificArgNameResolver } = route;
const { _, getInlineParseContent, getParseContent, parseSchema, getComponentByRef, require } = utils;
const { parameters, path, method, payload, query, formData, security, requestParams } = route.request;
const { type, errorType, contentTypes } = route.response;
const { raw, request, routeName } = route;
const { HTTP_CLIENT, RESERVED_REQ_PARAMS_ARG_NAMES } = config.constants;
const routeDocs = includeFile("./route-docs", { config, route, utils });
const queryName = (query && query.name) || "query";
const pathParams = _.values(parameters);
const pathParamsNames = _.map(pathParams, "name");

// Include the same dynamic naming logic as data-contracts.ejs
// Helper function to convert kebab-case to camelCase
const toCamelCase = (str) => {
  return str.replace(/-([a-z])/g, (match, letter) => letter.toUpperCase());
};

// Step 1: Collect and analyze all routes to detect conflicts
const analyzeRoutes = (routes, utils) => {
  const { _ } = utils;
  
  if (!routes || !routes.combined) {
    return { routesByClass: {}, conflictAnalysis: {}, allRoutes: [] };
  }

  // Collect all routes first
  const allRoutes = [];
  routes.combined.forEach(group => {
    if (group.routes) {
      allRoutes.push(...group.routes);
    }
  });

  // Group routes by class/module
  const routesByClass = {};
  allRoutes.forEach(route => {
    // Determine class name from path
    let className = 'Unknown';
    if (route.raw?.route) {
      const pathSegments = route.raw.route.split('/').filter(p => p && !p.startsWith('{'));
      if (pathSegments.length > 0) {
        className = _.upperFirst(pathSegments[1] || pathSegments[0] || 'Unknown');
      }
    }
    
    if (!routesByClass[className]) {
      routesByClass[className] = [];
    }
    routesByClass[className].push(route);
  });

  // Analyze conflicts within each class
  const conflictAnalysis = {};
  
  Object.keys(routesByClass).forEach(className => {
    const routes = routesByClass[className];
    const methodNames = {};

    routes.forEach(route => {
      // Extract base method name (without HTTP method prefix)
      const baseMethodName = extractBaseMethodName(route, utils);
      
      if (!methodNames[baseMethodName]) {
        methodNames[baseMethodName] = [];
      }
      methodNames[baseMethodName].push(route);
    });

    // Find conflicts within this class
    const conflicts = Object.keys(methodNames).filter(name => methodNames[name].length > 1);
    
    if (conflicts.length > 0) {
      conflictAnalysis[className] = {};
      conflicts.forEach(conflictName => {
        conflictAnalysis[className][conflictName] = methodNames[conflictName];
      });
    }
  });

  return { routesByClass, conflictAnalysis, allRoutes };
};

// Step 2: Extract base method name from route
const extractBaseMethodName = (route, utils) => {
  const { _ } = utils;
  
  if (!route.raw?.route) return 'unknown';
  
  const pathSegments = route.raw.route.split('/').filter(p => p && !p.startsWith('{'));
  
  if (pathSegments.length >= 2) {
    // Get the action from the last meaningful segment
    const action = pathSegments[pathSegments.length - 1];
    return toCamelCase(action);
  }
  
  if (pathSegments.length === 1) {
    // For single segment paths like /users, /auth
    const resource = pathSegments[0];
    return toCamelCase(resource);
  }
  
  return route.raw.method.toLowerCase();
};

// Step 3: Resolve conflicts dynamically
const resolveMethodNameConflicts = (route, conflictAnalysis, routesByClass, utils) => {
  const { _ } = utils;
  
  // Determine class name
  let className = 'Unknown';
  if (route.raw?.route) {
    const pathSegments = route.raw.route.split('/').filter(p => p && !p.startsWith('{'));
    if (pathSegments.length > 0) {
      className = _.upperFirst(pathSegments[1] || pathSegments[0] || 'Unknown');
    }
  }

  const baseMethodName = extractBaseMethodName(route, utils);
  const hasConflict = conflictAnalysis[className] && conflictAnalysis[className][baseMethodName];
  
  if (!hasConflict) {
    return baseMethodName;
  }

  // Different resolution strategies based on conflict type
  const conflictingRoutes = conflictAnalysis[className][baseMethodName];
  
  // Strategy 1: Path parameter differentiation
  if (hasPathParamConflict(conflictingRoutes)) {
    return resolvePathParamConflict(route, baseMethodName, utils);
  }
  
  // Strategy 2: Context from path segments (like jwt/login vs cookie/login)
  if (hasContextConflict(conflictingRoutes)) {
    return resolveContextConflict(route, baseMethodName, utils);
  }
  
  // Strategy 3: HTTP method prefix (fallback for other conflicts)
  return resolveHttpMethodConflict(route, baseMethodName, utils);
};

// Step 4: Detect different types of conflicts
const hasPathParamConflict = (conflictingRoutes) => {
  // Check if some routes have path params and others don't
  const withParams = conflictingRoutes.filter(r => r.raw.route.includes('{'));
  const withoutParams = conflictingRoutes.filter(r => !r.raw.route.includes('{'));
  return withParams.length > 0 && withoutParams.length > 0;
};

const hasContextConflict = (conflictingRoutes) => {
  // Check if routes have different context segments (like jwt vs cookie)
  const contexts = conflictingRoutes.map(route => {
    const pathSegments = route.raw.route.split('/').filter(p => p && !p.startsWith('{'));
    return pathSegments.length >= 2 ? pathSegments[pathSegments.length - 2] : null;
  }).filter(c => c !== null);
  
  return new Set(contexts).size > 1;
};

// Step 5: Apply resolution strategies
const resolvePathParamConflict = (route, baseMethodName, utils) => {
  const { _ } = utils;
  
  if (route.raw.route.includes('{')) {
    // Extract parameter name and create method name like getUsersByUserId
    const paramMatch = route.raw.route.match(/\{([^}]+)\}/);
    if (paramMatch) {
      const paramName = paramMatch[1];
      const camelParamName = paramName.replace(/_([a-z])/g, (match, letter) => letter.toUpperCase());
      return `${route.raw.method.toLowerCase()}${_.upperFirst(baseMethodName)}By${_.upperFirst(camelParamName)}`;
    }
  }
  
  // For non-parameterized routes, add HTTP method prefix
  return `${route.raw.method.toLowerCase()}${_.upperFirst(baseMethodName)}`;
};

const resolveContextConflict = (route, baseMethodName, utils) => {
  const { _ } = utils;
  
  const pathSegments = route.raw.route.split('/').filter(p => p && !p.startsWith('{'));
  if (pathSegments.length >= 2) {
    const context = pathSegments[pathSegments.length - 2];
    return `${baseMethodName}${_.upperFirst(toCamelCase(context))}`;
  }
  
  // Fallback to HTTP method prefix
  return `${route.raw.method.toLowerCase()}${_.upperFirst(baseMethodName)}`;
};

const resolveHttpMethodConflict = (route, baseMethodName, utils) => {
  const { _ } = utils;
  return `${route.raw.method.toLowerCase()}${_.upperFirst(baseMethodName)}`;
};

// Step 6: Generate input/result type names with cross-class conflict detection
const generateTypeNames = (route, methodName, allRoutes, utils) => {
  const { _ } = utils;
  
  // Determine class name
  let className = 'Unknown';
  if (route.raw?.route) {
    const pathSegments = route.raw.route.split('/').filter(p => p && !p.startsWith('{'));
    if (pathSegments.length > 0) {
      className = _.upperFirst(pathSegments[1] || pathSegments[0] || 'Unknown');
    }
  }

  const pascalMethodName = methodName.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()).replace(/\s+/g, '');
  
  // Check for cross-class conflicts for types
  const samePascalNames = allRoutes.filter(r => {
    if (r === route) return false;
    
    const analysis = analyzeRoutes({combined: [{routes: allRoutes}]}, utils);
    const otherMethodName = resolveMethodNameConflicts(r, analysis.conflictAnalysis, analysis.routesByClass, utils);
    const otherPascalName = otherMethodName.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()).replace(/\s+/g, '');
    
    return otherPascalName === pascalMethodName;
  });

  // If there are cross-class conflicts, add class name to type names
  const needsClassPrefix = samePascalNames.length > 0;
  
  if (needsClassPrefix) {
    return {
      inputTypeName: `${pascalMethodName}${className}Input`,
      resultTypeName: `${pascalMethodName}${className}Result`
    };
  } else {
    return {
      inputTypeName: `${pascalMethodName}Input`,
      resultTypeName: `${pascalMethodName}Result`
    };
  }
};

// Main function to get resolved method name and type names for a route
const getResolvedNames = (route, routes, utils) => {
  const analysis = analyzeRoutes(routes, utils);
  const methodName = resolveMethodNameConflicts(route, analysis.conflictAnalysis, analysis.routesByClass, utils);
  const typeNames = generateTypeNames(route, methodName, analysis.allRoutes, utils);
  
  return {
    methodName,
    inputTypeName: typeNames.inputTypeName,
    resultTypeName: typeNames.resultTypeName
  };
};

const argToTmpl = ({ name, optional, type, defaultValue }) => `${name}${!defaultValue && optional ? '?' : ''}: ${type}${defaultValue ? ` = ${defaultValue}` : ''}`;

const rawWrapperArgs = config.extractRequestParams ?
    _.compact([
        requestParams && {
          name: pathParams.length ? `{ ${_.join(pathParamsNames, ", ")}, ...${queryName} }` : queryName,
          optional: false,
          type: getInlineParseContent(requestParams),
        },
        ...(!requestParams ? pathParams : []),
        payload,
    ]) :
    _.compact([
        ...pathParams,
        query,
        payload,
    ])

const wrapperArgs = _
    // Sort by optionality
    .sortBy(rawWrapperArgs, [o => o.optional])
    .map(argToTmpl)
    .join(', ')

const bodyTmpl = _.get(payload, "name") || null;
const queryTmpl = (query != null && queryName) || null;

const hasParams = wrapperArgs.length > 0;

const isValidIdentifier = (name) => /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(name);

// Fix parameter type to include Types namespace if it's a custom type
const getTypeWithNamespace = (paramType) => {
  if (!paramType) return 'any';
  // If it's a primitive type, return as-is
  if (['string', 'number', 'boolean', 'any', 'unknown', 'void'].includes(paramType)) {
    return paramType;
  }
  // If it already has Types namespace, return as-is
  if (paramType.startsWith('Types.')) {
    return paramType;
  }
  // Add Types namespace for custom types
  return `Types.${paramType}`;
};

// Determine the correct parameter type using method-specific types
let requestParamsType = 'any';
if (requestParams) {
  requestParamsType = getTypeWithNamespace(getInlineParseContent(requestParams));
} else if (payload && payload.type) {
  // Use the payload type directly for request body
  const payloadType = getTypeWithNamespace(payload.type);
  if (query && query.type) {
    const queryType = getTypeWithNamespace(query.type);
    requestParamsType = `{ data: ${payloadType} } & ${queryType}`;
  } else {
    requestParamsType = `{ data: ${payloadType} }`;
  }
} else if (query && query.type) {
  requestParamsType = getTypeWithNamespace(query.type);
}

// Simplified consistent naming that matches data-contracts logic
const getConsistentNames = (route, utils) => {
  const { _ } = utils;
  const path = route.raw.route;
  const method = route.raw.method.toLowerCase();
  const pathSegments = path.split('/').filter(p => p && !p.startsWith('{'));
  
  // Extract base name from path
  let baseName = '';
  if (pathSegments.length >= 2) {
    baseName = toCamelCase(pathSegments[pathSegments.length - 1]);
  } else if (pathSegments.length === 1) {
    baseName = toCamelCase(pathSegments[0]);
  }
  
  // Selective HTTP method prefixing - only when needed
  let methodName = baseName;
  
  // Rule 1: Parameterized routes - add ByParam suffix to avoid conflicts
  if (path.includes('{')) {
    const paramMatch = path.match(/\{([^}]+)\}/);
    if (paramMatch) {
      const paramName = paramMatch[1].replace(/_([a-z])/g, (match, letter) => letter.toUpperCase());
      methodName = `${method}${_.upperFirst(baseName)}By${_.upperFirst(paramName)}`;
    }
  }
  // Rule 2: Context-specific routes (jwt/login, cookie/login) 
  else if (pathSegments.length >= 2 && ['login', 'logout'].includes(baseName.toLowerCase())) {
    const context = pathSegments[pathSegments.length - 2];
    methodName = `${baseName}${_.upperFirst(toCamelCase(context))}`;
  }
  // Rule 3: Only add HTTP prefix for known multi-method endpoints
  else if (pathSegments.length >= 2 && ['tiers', 'ratelimits', 'me'].includes(baseName.toLowerCase())) {
    methodName = `${method}${_.upperFirst(baseName)}`;
  }
  // Rule 4: Single-segment multi-method resources  
  else if (pathSegments.length === 1 && ['users', 'plans'].includes(pathSegments[0])) {
    methodName = `${method}${_.upperFirst(baseName)}`;
  }
  // Rule 5: Keep simple names for single-action routes (register, verify, etc.)
  else {
    methodName = baseName;
  }
  
  // Generate consistent type names
  const pascalMethodName = methodName.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()).replace(/\s+/g, '');
  
  return {
    methodName,
    inputTypeName: `${pascalMethodName}Input`,
    resultTypeName: `${pascalMethodName}Result`
  };
};

const resolvedNames = getConsistentNames(route, utils);
const simpleMethodName = resolvedNames.methodName;
const inputTypeName = resolvedNames.inputTypeName;
const resultTypeName = resolvedNames.resultTypeName;

// Use method-specific types instead of original types
const methodInputType = `Types.${inputTypeName}`;
const methodResultType = `Types.${resultTypeName}`;
%>

/**
<%~ routeDocs.description %>

 *<% /* Here you can add some other JSDoc tags */ %>

<%~ routeDocs.lines %>

 * @param host Optional base URL host (e.g., 'https://api.example.com') to override the default relative URL
 */
<% if (isValidIdentifier(simpleMethodName)) { %><%~ simpleMethodName %><% } else { %>"<%~ simpleMethodName %>"<% } %> = <% if (hasParams) { %>(params: Signal<<%~ methodInputType %> | undefined>, host?: string)<% } else { %>(trigger?: Signal<any>, host?: string)<% } %> => {
  return httpResource<% if (methodResultType && methodResultType !== 'void' && methodResultType !== 'any') { %><<%~ methodResultType %>><% } %>(() => {
    <% if (hasParams) { %>
    const resolvedParams = params();
    if (!resolvedParams) return undefined;
    <% } else { %>
    if (!trigger?.()) return undefined;
    <% } %>
    
    <% if (pathParams.length > 0) { %>
    let url = host ? `${host}<%~ raw.route %>` : '<%~ raw.route %>';
    <% pathParams.forEach(param => { %>
    <% if (hasParams) { %>
    url = url.replace('{<%~ param.name %>}', String(resolvedParams.<%~ param.name %>));
    <% } %>
    <% }); %>
    <% } else { %>
    const url = host ? `${host}<%~ raw.route %>` : '<%~ raw.route %>';
    <% } %>

    <% if (query) { %>
    const queryParams: Record<string, string> = {};
    <% if (hasParams) { %>
    // Extract query parameters (excluding path parameters)
    <% if (pathParams.length > 0) { %>
    const pathParamNames = [<%~ pathParamsNames.map(name => `'${name}'`).join(', ') %>];
    Object.entries(resolvedParams).forEach(([key, value]) => {
      if (!pathParamNames.includes(key) && value !== undefined && value !== null) {
        queryParams[key] = String(value);
      }
    });
    <% } else { %>
    Object.entries(resolvedParams).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        queryParams[key] = String(value);
      }
    });
    <% } %>
    <% } %>
    <% } %>

    return {
      url,
      method: '<%~ _.upperCase(method) %>',
      <% if (query) { %>
      params: queryParams,
      <% } %>
      <% if (bodyTmpl && hasParams) { %>
      body: resolvedParams,
      <% } %>
      <% if (requestBodyInfo.contentType) { %>
      headers: {
        'Content-Type': '<%~ requestBodyInfo.contentType %>'
      }
      <% } %>
    };
  });
}; 