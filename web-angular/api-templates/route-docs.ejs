<%
const { config, route, utils, routes } = it;
const { _, formatDescription, fmtToJSDocLine, pascalCase, require } = utils;
const { raw, request, routeName, path, method } = route;

// Load dynamic naming utilities
const namingUtils = includeFile("./naming-utils", { utils });

// Collect all routes for analysis
const allRoutes = [];
if (routes && routes.combined) {
  routes.combined.forEach(group => {
    if (group.routes) {
      allRoutes.push(...group.routes);
    }
  });
}

// Get dynamic naming for this route
const routeNaming = namingUtils.getRouteNaming(route, allRoutes, utils);

// Use dynamic naming from the analysis
const simpleMethodName = routeNaming.methodName;

const jsDocDescription = raw.description ?
    ` * @description ${formatDescription(raw.description, true)}` :
    fmtToJSDocLine('No description', { eol: false });

// Filter responses to only show successful ones (200-299 status codes)
const successfulResponses = config.generateResponses && raw.responsesTypes.length
    ? raw.responsesTypes.filter(({ status, isSuccess }) => {
        const statusCode = parseInt(status);
        return statusCode >= 200 && statusCode < 300;
      })
    : [];

const jsDocLines = _.compact([
    _.size(raw.tags) && ` * @tags ${raw.tags.join(", ")}`,
    ` * @name ${_.upperFirst(simpleMethodName)}`,
    raw.summary && ` * @summary ${raw.summary}`,
    ` * @request ${_.upperCase(request.method)}:${raw.route}`,
    raw.deprecated && ` * @deprecated`,
    routeName.duplicate && ` * @originalName ${routeName.original}`,
    routeName.duplicate && ` * @duplicate`,
    request.security && ` * @secure`,
    ...successfulResponses.map(
        ({ type, status, description }) =>
            ` * @response \`${status}\` \`${_.replace(_.replace(type, /\/\*/g, "\\*"), /\*\//g, "*\\")}\` ${description}`,
    ),
]).map(str => str.trimEnd()).join("\n");

return {
  description: jsDocDescription,
  lines: jsDocLines,
}
%>
